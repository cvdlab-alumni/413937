/**
 * The model of a coniferous forest can be generated by building a very 
 * simplified tree model. The tree contains a cylinder and cone (with parametric
 * height, radius and angular discretization). The tree model must be
 * instantiated several times using as a translation vector on the scene the
 * three numbers generated by the coordinated functions of the digital terrain
 * model.
 * 
 * Select one or more subsets of the ground to place the wooded areas on the 
 * slopes of the mountainous scene, adding a random term to increase the 
 * naturalness of the placement.
 * 
 * NB. You can complicate the model of the tree at will to make it less 
 * "mechanical", for example correcting with random coefficients the height, 
 * radius and angular discretization parameter of the crown.
 **/


/*********************************** ex.1,2 ***********************************/
// change parameters to change world dimensions and divisions:
var worldDims = [50,50];
var worldDivs = [64,64];
var seed1 = 3 + 3*Math.random();
var seed2 = .2 + .2*Math.random();
var seed3 = 5 + 2*Math.random();
var worldDomain = PROD1x1([INTERVALS(worldDims[0])(worldDivs[0]),INTERVALS(worldDims[1])(worldDivs[1])]);
var x = function(u,v){ return u; };
var y = function(u,v){ return v; };
var z = function(u,v){
	return SIN(COS(u/seed1)*PI) + seed2 + COS(SIN(v/seed3)*PI) + seed2 * COS(v + u/(seed3*3/2)) - seed3*SIN(PI*u/25)*SIN(PI*v/25);
};
var mappingFunction = function(point){
	return [x(point[0], point[1]), y(point[0], point[1]), z(point[0], point[1]) + (.1 * (Math.random()-.5))];
};
var terrain = COLOR([139./255, 69./255, 19./255])(MAP(mappingFunction)(worldDomain));
var waterColor = [0, 191/255, 255/255];
var lakes = T([2])([-8])(COLOR(waterColor)(CUBOID([worldDims[0], worldDims[1], 6])));
var scene = STRUCT([terrain, lakes]);
/******************************************************************************/


// Utils functions:
var ROTATIONAL_SOLID = function(points){
	/*
	Similar to ROTATIONAL_SURFACE but takes points, not curves.
	*/
	return function(angle){ return function(divs){
		var domain = PROD1x1([INTERVALS(points.length-1)(points.length-1), INTERVALS(angle)(divs)]);
		var profile = function(x) { return points[x[0]];}
		return MAP(ROTATIONAL_SURFACE(profile))(domain);
	}}
};

var tree = function(height, radius, divs){
	return STRUCT([
		COLOR([0,.75,0])(ROTATIONAL_SOLID([[0,0,height],[radius,0,height/7],[0,0,height/7]])(2*PI)(divs)),
		COLOR([139/255, 69/255, 18/255])(ROTATIONAL_SOLID([[0,0,-.5],[radius/3,0,-.5],[radius/3,0,height/7]])(2*PI)(divs))
	]);
};

/*
 * function that return a randomized tree:
 */
var randomTree = function(){
	return tree(.5 + .5*Math.random(), .1 + .3*Math.random(), 4 + Math.floor(9*Math.random()));
};


/*
 * Trees are positioned according to the z function:
 * trees only grows at an altitude greater than a certain value...
 * Trees are planted using a grid with less divisions than the world,
 * then each coordinate is randomized adding a random value.
 */

/*
 * Parameters of placeTrees:
 * - altitude is the minimum altitude at which trees grows.
 * - density is the forest density (in a range 0-1 [maybe also more than 1...]]).
 */
var trees = [];
var placeTrees = function(altitude, density){
	var grid = PROD1x1([INTERVALS(worldDims[0])(Math.floor(worldDivs[0]*density)),INTERVALS(worldDims[1])(Math.floor(worldDivs[1]*density))]);
	var mappingTrees = function(point){
		var fuzzyX = point[0] + Math.random()-.5;
		var fuzzyY = point[1] + Math.random()-.5;
		if (z(fuzzyX, fuzzyY) > altitude)
			trees.push(T([0,1,2])([fuzzyX, fuzzyY, z(fuzzyX, fuzzyY)])(randomTree()));
		// dummy return:
		return [0,0,0];
	};
	MAP(mappingTrees)(grid);
};
placeTrees(1.3, 1);
trees = STRUCT(trees);

DRAW(trees);

